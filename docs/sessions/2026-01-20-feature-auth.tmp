# Session: Supabase Auth with Multi-Tenant Support
**Date:** 2026-01-20
**Started:** 14:30
**Last Updated:** 17:45
**Branch:** feature/KT-101-supabase-auth

---

## Current State

Implementing authentication flow for KT-Portal using Supabase Auth. Supporting email/password, magic links, and OAuth with multi-tenant context.

### Completed
- [x] Set up Supabase Auth with @supabase/ssr
- [x] Created auth callback route for OAuth/magic links
- [x] Implemented Next.js middleware for auth protection
- [x] Added profile creation trigger on user signup
- [x] Fixed cookie handling in Server Components

### In Progress
- [ ] Add Google OAuth provider
- [ ] Implement 2FA with TOTP
- [ ] Add organization invite flow

### Blockers Encountered
1. **@supabase/ssr cookie handling** - Had to use the new `cookies()` API pattern for Next.js 14
2. **Server Component auth** - `getUser()` works but `getSession()` doesn't in Server Components
3. **Profile creation** - Needed database trigger since we can't use `onAuthStateChange` on server

### Key Decisions Made
- Using `@supabase/ssr` (not `@supabase/auth-helpers-nextjs` which is deprecated)
- Magic links as primary auth method for better UX
- Profile record created via database trigger, not client-side
- Organization assigned on invite or first login

### Supabase Client Setup
```typescript
// lib/supabase/client.ts (Browser)
import { createBrowserClient } from '@supabase/ssr'
import { Database } from '@/types/database'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// lib/supabase/server.ts (Server Components & API Routes)
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { Database } from '@/types/database'

export async function createServerSupabaseClient() {
  const cookieStore = cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Called from Server Component - ignore
          }
        },
      },
    }
  )
}
```

### Next.js Middleware for Auth
```typescript
// middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // IMPORTANT: Use getUser() not getSession()
  // getSession() reads from storage which may have stale data
  const { data: { user } } = await supabase.auth.getUser()

  // Redirect to login if not authenticated
  if (!user && request.nextUrl.pathname.startsWith('/dashboard')) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    url.searchParams.set('redirect', request.nextUrl.pathname)
    return NextResponse.redirect(url)
  }

  // Redirect to dashboard if already logged in
  if (user && (request.nextUrl.pathname === '/login' || request.nextUrl.pathname === '/signup')) {
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```

### Auth Callback Route
```typescript
// app/auth/callback/route.ts
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createServerSupabaseClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // Return to login with error
  return NextResponse.redirect(`${origin}/login?error=auth_callback_error`)
}
```

### Profile Creation Trigger
```sql
-- supabase/migrations/20260120000001_profile_trigger.sql

-- Create profiles table
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id),
  email TEXT NOT NULL,
  name TEXT,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'client',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own profile"
  ON profiles FOR SELECT
  USING (id = auth.uid());

CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  USING (id = auth.uid())
  WITH CHECK (
    id = auth.uid()
    AND organization_id = (
      SELECT organization_id FROM profiles WHERE id = auth.uid()
    )
    AND role = (
      SELECT role FROM profiles WHERE id = auth.uid()
    )
  );

-- Trigger to create profile on signup
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();
```

### Login Page Component
```typescript
// app/(auth)/login/page.tsx
'use client'

import { useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState('')
  const supabase = createClient()

  const handleMagicLink = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)

    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: `${window.location.origin}/auth/callback`,
      },
    })

    if (error) {
      setMessage(error.message)
    } else {
      setMessage('Check your email for the magic link!')
    }
    setLoading(false)
  }

  return (
    <form onSubmit={handleMagicLink} className="space-y-4">
      <Input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
      />
      <Button type="submit" disabled={loading} className="w-full">
        {loading ? 'Sending...' : 'Send Magic Link'}
      </Button>
      {message && <p className="text-sm text-muted-foreground">{message}</p>}
    </form>
  )
}
```

### Notes for Next Session
- Add Google OAuth configuration in Supabase dashboard
- Implement organization invite flow with email tokens
- Add 2FA enrollment page
- Consider adding passkey/WebAuthn support
- Handle custom domain auth redirects for partners

### Context to Load
```
src/lib/supabase/client.ts
src/lib/supabase/server.ts
src/app/auth/callback/route.ts
src/app/(auth)/login/page.tsx
middleware.ts
supabase/migrations/20260120000001_profile_trigger.sql
```

---

## Session Log

**14:30** - Started session, goal is Supabase Auth implementation

**14:45** - Set up @supabase/ssr clients. Key insight: use different clients for browser vs server.

**15:20** - Middleware working but hit issue with `getSession()`. Switched to `getUser()` which makes server request to verify token.

**15:45** - Auth callback route working. Magic links successfully redirect to dashboard.

**16:00** - Profile creation issue: can't use `onAuthStateChange` in Server Components. Solution: database trigger.

**16:30** - Database trigger created and tested. New users automatically get profile record.

**17:00** - Tested full flow: signup -> magic link -> callback -> profile created -> dashboard access.

**17:45** - Saving session state. All tests passing: `npm test -- auth`

### Related KT-Portal Considerations
- Partner custom domains need separate auth redirects configured in Supabase
- Organization assignment happens via invite token or admin action
- Magic links are tenant-aware (redirect to correct subdomain)
