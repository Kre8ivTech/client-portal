# Session: Supabase Realtime Subscription Memory Leak
**Date:** 2026-01-17
**Started:** 09:00
**Last Updated:** 12:00
**Branch:** fix/KT-089-realtime-memory-leak

---

## Current State

Investigating memory leak in production. Client-side memory growing unbounded when users navigate between ticket pages.

### Completed
- [x] Set up Chrome DevTools memory profiling
- [x] Identified leak source: Supabase Realtime channels not being cleaned up
- [x] Fixed leak in useRealtimeTickets hook
- [x] Verified fix with navigation stress test

### Root Cause
Supabase Realtime channels were being created on component mount but not properly removed on unmount. After navigating between pages ~50 times, memory grew from 50MB to 500MB due to orphaned subscriptions.

### The Fix
```typescript
// hooks/use-realtime-tickets.ts

// Before (leaking)
'use client'

import { useEffect } from 'react'
import { createClient } from '@/lib/supabase/client'

export function useRealtimeTickets() {
  const supabase = createClient()

  useEffect(() => {
    const channel = supabase
      .channel('tickets-changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'tickets' },
        (payload) => console.log(payload)
      )
      .subscribe()
    // Missing cleanup!
  }, [])
}

// After (fixed)
'use client'

import { useEffect } from 'react'
import { useQueryClient } from '@tanstack/react-query'
import { createClient } from '@/lib/supabase/client'

export function useRealtimeTickets() {
  const queryClient = useQueryClient()
  const supabase = createClient()

  useEffect(() => {
    const channel = supabase
      .channel('tickets-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'tickets' },
        (payload) => {
          queryClient.invalidateQueries({ queryKey: ['tickets'] })
        }
      )
      .subscribe()

    // Proper cleanup on unmount
    return () => {
      supabase.removeChannel(channel)
    }
  }, [queryClient, supabase])
}
```

### Additional Fix: Stable Supabase Client
```typescript
// The supabase client was being recreated on every render
// This caused new channels to be created even with cleanup

// Before
export function useRealtimeTickets() {
  const supabase = createClient() // New instance every render!
  // ...
}

// After - use useMemo or move outside component
import { useMemo } from 'react'

export function useRealtimeTickets() {
  const supabase = useMemo(() => createClient(), [])
  // ...
}

// Or better - create singleton in client.ts
let client: SupabaseClient | null = null

export function createClient() {
  if (client) return client
  client = createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
  return client
}
```

### Debugging Technique Worth Saving
1. Open Chrome DevTools > Memory tab
2. Take heap snapshot at T=0
3. Navigate between pages 10+ times
4. Take heap snapshot at T=1
5. Compare snapshots - look for "Detached" elements
6. Filter by "RealtimeChannel" or similar

### Notes for Next Session
- Audit all other realtime subscriptions in the codebase
- Consider creating a custom hook factory for realtime subscriptions
- Add ESLint rule to warn about missing cleanup in useEffect

### Context to Load
```
src/hooks/use-realtime-tickets.ts
src/hooks/use-realtime-messages.ts
src/lib/supabase/client.ts
```

### Related KT-Portal Modules
- Live Chat (Supabase Realtime Presence)
- Ticket queue position updates
- Notification center
